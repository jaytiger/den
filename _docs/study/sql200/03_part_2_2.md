---
title: "SQL 200 - Part II-2"
permalink: /docs/study/sql200/part2_2/
last_modified_at: 2022-07-03T10:00:00
layout: single
#classes: wide
toc: true
toc_sticky: true
sidebar:
  nav: "sql200"
---

## Part 2. SQL 기초 다지기

#### 41. 데이터 분석 함수로 순위 출력하기 ① (RANK)

```sql
SELECT ename, job, sal, RANK() OVER (ORDER BY sal DESC) rank
  FROM `bigdata-adhoc.open_mart_ds.emp`
 WHERE job IN ('ANALYST', 'MANAGER')
;
```

집계함수와 분석함수의 가장 큰 차이는 집계 함수는 결과값이 집단(그룹)에 대해서 하나만 생성되는 반면, 분석 함수는 집단 구성원 각각에 대해서 만들어 진다는 점입니다.

따라서, 쿼리 수행으로 만들어지는 결과 테이블의 크기는 집계 함수의 경우 **GROUP BY** 에 나열된 컬럼값들로 만들 수 있는 조합의 갯수와 동일합니다. 집계가 이루어지면 결과 테이블은 원 테이블의 크기(행의 갯수)보다 줄어들게 됩니다.

분석함수는 집단이 아닌 각 구성원(테이블의 행)에 대해서 하나의 결과값이 생성되기 때문에 쿼리 수행 전후의 테이블의 크기가 동일합니다.

```sql
SELECT ename, job, sal, RANK() OVER (PARTITION BY job ORDER BY sal DESC) rank
  FROM `bigdata-adhoc.open_mart_ds.emp`;
```
#### 42. 데이터 분석 함수로 순위 출력하기 ② (DENSE_RANK)

```sql
SELECT ename, job, sal,
       RANK() OVER (PARTITION BY job ORDER BY sal DESC) rank,
       DENSE_RANK() OVER (PARTITION BY job ORDER BY sal DESC) dense_rank
  FROM `bigdata-adhoc.open_mart_ds.emp`
 WHERE job IN ('ANALYST', 'MANAGER');
```

```sql
-- 예제_042-2.txt
SELECT ename, job, sal,
       DENSE_RANK() OVER (PARTITION BY job ORDER BY sal DESC) dense_rank
  FROM `bigdata-adhoc.open_mart_ds.emp`
 WHERE hiredate BETWEEN  '1981-01-01' AND '1981-12-31';
```

교재의 아래 쿼리는 BigQuery에서 직접적으로 지원하지 않는 **WITHIN GROUP** 구문을 사용하고 있습니다.
이 구문은 집계 함수에서 **순서(ORDER)** 를 사용할 수 있게 보조하는 문법적인 장치입니다.

```sql
-- PL/SQL, not BigQuery
SELECT DENSE_RANK(2975) WITHIN GROUP (ORDER BY sal DESC) rank FROM emp;
```

**그룹 내** 에서 **2975** 값의 rank를 구하는 함수입니다.  동일한 결과를 만드는 BigQuery의 코드는 다음과 같습니다.

```sql
SELECT DISTINCT DENSE_RANK() OVER (ORDER BY sal DESC) rank
  FROM `bigdata-adhoc.open_mart_ds.emp`
 WHERE sal = 2975;
```

동일하게 입사일이 **'1981-11-17'** 인 직원이 몇 번째 입사자인지 구하는 쿼리는 다음과 같습니다.
```sql
-- PL/SQL, not BigQuery
SELECT DENSE_RANK('81/11/17') WITHIN GROUP (ORDER BY hiredate ASC) rank FROM emp;

-- BigQuery
SELECT DISTINCT DENSE_RANK() OVER (ORDER BY hiredate DESC) rank
  FROM `bigdata-adhoc.open_mart_ds.emp`
 WHERE hiredate = '1981-11-17'
;
```

#### 43. 데이터 분석 함수로 순위 출력하기 ② (DENSE_RANK)

```sql
SELECT ename, job, sal,
       NTILE(4) OVER (ORDER BY sal DESC NULLS LAST) tile,
  FROM `bigdata-adhoc.open_mart_ds.emp`
 WHERE job IN ('ANALYST', 'MANAGER', 'CLERK')
;
```

### 44. 데이터 분석 함수로 순위의 비율 출력하기 (CUME_DIST)

누적분포(Cumulative Distribution) 함수

```sql
SELECT ename, sal,
       RANK() OVER (ORDER BY sal DESC) AS rank,
       DENSE_RANK() OVER (ORDER BY sal DESC) AS dense_rank,
       CUME_DIST() OVER (ORDER BY sal DESC) AS cum_dist,
  FROM `bigdata-adhoc.open_mart_ds.emp`
;
```

```sql
SELECT ename, sal,
       RANK() OVER (PARTITION BY job ORDER BY sal DESC) AS rank,
       CUME_DIST() OVER (PARTITION BY ORDER BY sal DESC) AS cum_dist,
  FROM `bigdata-adhoc.open_mart_ds.emp`
;
```

### 45. 데이터 분석 함수로 데이터를 가로로 출력하기 (LISTAGG)

```sql
-- PL/SQL, BigQuery 미지원
SELECT deptno, LISTAGG(ename, ',') WITHIN GROUP (ORDER BY ename) AS employee
  FROM emp
 GROUP BY deptno;
```
**LISTAGG** 는 BigQuery에서 미지원되는 함수입니다. BigQuery에서는 동일한 기능을 제공하는 **STRING_AGG** 함수를 사용합니다.

```sql
-- BigQuery
SELECT deptno, STRING_AGG(ename,  ',' ORDER BY ename) AS employee
  FROM `bigdata-adhoc.open_mart_ds.emp`
 GROUP BY deptno;
```

```sql
SELECT job, STRING_AGG(ename || '(' || sal || ')',  ',' ORDER BY ename) AS employee
  FROM `bigdata-adhoc.open_mart_ds.emp`
 GROUP BY job;
```

### 46. 데이터 분석 함수로 바로 전 행과 다음 행 출력하기 (LAG, LEAD)

```sql
SELECT empno, ename, sal,
       LAG(sa1, 1) OVER (ORDER BY sal ASC) pre,
       LEAD(sa1, 1) OVER (ORDER BY sal ASC) next,
  FROM `bigdata-adhoc.open_mart_ds.emp`
 WHERE job IN ('ANALYST', 'MANAGER')
```

```sql
SELECT empno, ename, hiredate,
       LAG(hiredate, 1) OVER (ORDER BY hiredate ASC) pre,
       LEAD(hiredate, 1) OVER (ORDER BY hiredate ASC) next,
  FROM `bigdata-adhoc.open_mart_ds.emp`
 WHERE job IN ('ANALYST', 'MANAGER')
```

```sql
SELECT deptno, empno, ename, hiredate,
       LAG(hiredate, 1) OVER (PARTITION BY deptno ORDER BY hiredate ASC) pre,
       LEAD(hiredate, 1) OVER (PARTITION BY deptno ORDER BY hiredate ASC) next,
  FROM `bigdata-adhoc.open_mart_ds.emp`
;
```

### 47. COLUMN을 ROW로 출력하기 ① (SUM + DECODE)

>**DECODE** 함수는 BigQuery에서 제공되지 않아 **IF** 함수를 사용하여 동일한 결과가 나오도록 작성하면 다음과 같습니다.

부서별 월급의 총합을 구해보도록 하겠습니다. **GROUP BY**를 이용하여 산출하면 다음과 같습니다.

```sql
SELECT deptno, SUM(sal) AS total_sal
  FROM `bigdata-adhoc.open_mart_ds.emp`
 GROUP BY deptno;

 +-----+--------+-----------+
| Row | deptno | total_sal |
+-----+--------+-----------+
|   1 |     30 |      9400 |
|   2 |     10 |      8750 |
|   3 |     20 |     10875 |
+-----+--------+-----------+
```

이 경우 부서별 월급 총합이 세로로 출력이 되는데 가로로 출력을 하고 싶을 때 다음과 같이 집계함수와 IF함수를 이용하게 됩니다.
각각의 컬럼은 하나의 부서코드에 해당하며 해당 부서코드의 **sal**만 더해지도록 **IF(dept = 10, sal, NULL)** 함수를 먼저 적용한 후 **SUM**을 합니다.

```sql
SELECT SUM(IF(deptno = 10, sal, NULL)) AS `_10`,
       SUM(IF(deptno = 20, sal, NULL)) AS `_20`,
       SUM(IF(deptno = 30, sal, NULL)) AS `_30`,
  FROM `bigdata-adhoc.open_mart_ds.emp`

+-----+------+-------+------+
| Row | _10  |  _20  | _30  |
+-----+------+-------+------+
|   1 | 8750 | 10875 | 9400 |
+-----+------+-------+------+
```
**PIVOT** 쿼리를 직접 지원하지 않는 SQL 에서는 이러한 방법을 통해 세로 출력을 가로 출력으로 피봇팅 (Pivoting)을 합니다.

같은 방식으로 직군별 월급 총합을 구하면 다음과 같습니다.
```sql
SELECT SUM(IF(job = 'ANALYST', sal, NULL)) AS analysist,
       SUM(IF(job = 'CLERK', sal, NULL)) AS clerk,
       SUM(IF(job = 'MANAGER', sal, NULL)) AS manager,
       SUM(IF(job = 'SALESMAN', sal, NULL)) AS salesman,
  FROM `bigdata-adhoc.open_mart_ds.emp`;

+-----+-----------+-------+---------+----------+
| Row | analysist | clerk | manager | salesman |
+-----+-----------+-------+---------+----------+
|   1 |      6000 |  4150 |    8275 |     5600 |
+-----+-----------+-------+---------+----------+
```

다음은 조금 세분화하여 부서, 직군별 월급 총합을 산출해 보겠습니다. 

```sql
SELECT deptno,
       SUM(IF(job = 'ANALYST', sal, NULL)) AS analysist,
       SUM(IF(job = 'CLERK', sal, NULL)) AS clerk,
       SUM(IF(job = 'MANAGER', sal, NULL)) AS manager,
       SUM(IF(job = 'SALESMAN', sal, NULL)) AS salesman,
  FROM `bigdata-adhoc.open_mart_ds.emp`
 GROUP BY deptno;

+-----+--------+-----------+-------+---------+----------+
| Row | deptno | analysist | clerk | manager | salesman |
+-----+--------+-----------+-------+---------+----------+
|   1 |     30 | null      |   950 |    2850 | 5600     |
|   2 |     10 | null      |  1300 |    2450 | null     |
|   3 |     20 | 6000      |  1900 |    2975 | null     |
+-----+--------+-----------+-------+---------+----------+
```

### 48. COLUMN을 ROW로 출력하기 ② PIVOT

**PIVOT** 구문을 사용하면 앞서의 **집계함수 + IF함수**  없이 손쉽게 피봇팅을 수행할 수 있습니다.

{% include figure image_path="https://miro.medium.com/max/722/1*-uwsgmqhhickvOq2rJykXQ.png" %}

```sql
SELECT * FROM (
    SELECT deptno, sal FROM `bigdata-adhoc.open_mart_ds.emp`
  ) PIVOT (SUM(sal) FOR deptno IN (10, 20, 30));
```
앞서의 직군별 월급 총합은 다음과 같이 피봇팅할 수 있다.

```sql
SELECT * FROM (
  SELECT job, sal FROM `bigdata-adhoc.open_mart_ds.emp`
) PIVOT (SUM(sal) FOR job IN ('ANALYST', 'CLERK', 'MANAGER', 'SALESMAN'));
```

부서, 직군별 월급 총합은 다음과 같다.
```sql
SELECT * FROM (
  SELECT job, sal FROM `bigdata-adhoc.open_mart_ds.emp`
) PIVOT (SUM(sal) FOR job IN ('ANALYST', 'CLERK', 'MANAGER', 'SALESMAN'));
```

**PIVOT** 쿼리의 구조를 살펴보면,
1. 서브쿼리를 사용하여 Pivoting에 참여하는 컬럼들만 남긴다.
2. 기준(차원) 컬럼이 하나 이상의 행으로 이루어진 집단(그룹)이기 때문에 집계함수를 사용해야 한다.
3. **FOR** 다음에는 각각의 컬럼으로 피봇팅이 이루어져야 하는 피봇 컬럼을 지정한다.
4. **IN** 리스트에는 피봇팅 시킬 컬럼값들을 기술한다.  사전에 값을 알지 못하는 경우는 Dynamic SQL로 동적으로 생성이 가능하다.

### 49. ROW를 COLUMN으로 출력하기 (UNPIVOT)

```sql
CREATE TEMP TABLE order1 AS
SELECT * FROM UNNEST([
  STRUCT('SMITH' AS ename, 'BICYCLE' AS item, 2 AS cnt),
  ('SMITH', 'CAMERA', 3),
  ('SMITH', 'NOTEBOOK', 1),
  ('ALLEN', 'BICYCLE', 1),
  ('ALLEN', 'CAMERA', 2),
  ('ALLEN', 'NOTEBOOK', 3),
  ('KING', 'BICYCLE', 3),
  ('KING', 'CAMERA', 2),
  ('KING', 'NOTEBOOK', 2)
]);

CREATE TEMP TABLE order2 AS
SELECT * FROM order1 PIVOT (SUM(cnt) FOR item IN ('BICYCLE', 'CAMERA', 'NOTEBOOK'));

+-----+-------+---------+--------+----------+
| Row | ename | BICYCLE | CAMERA | NOTEBOOK |
+-----+-------+---------+--------+----------+
|   1 | KING  |       3 |      2 |        2 |
|   2 | ALLEN |       1 |      2 |        3 |
|   3 | SMITH |       2 |      3 |        1 |
+-----+-------+---------+--------+----------+


SELECT * FROM order2 UNPIVOT(cnt for item IN (bicycle, camera, notebook));

+-----+-------+-----+----------+
| Row | ename | cnt |   item   |
+-----+-------+-----+----------+
|   1 | SMITH |   2 | bicycle  |
|   2 | SMITH |   3 | camera   |
|   3 | SMITH |   1 | notebook |
|   4 | KING  |   3 | bicycle  |
|   5 | KING  |   2 | camera   |
|   6 | KING  |   2 | notebook |
|   7 | ALLEN |   1 | bicycle  |
|   8 | ALLEN |   2 | camera   |
|   9 | ALLEN |   3 | notebook |
+-----+-------+-----+----------+
```

### 50. 데이터 분석 함수로 누적 데이터 출력하기 (SUM OVER)

분석함수를 이용하여 누적합을 구하는 방법은 다음과 같습니다.

```sql
SELECT empno, ename, sal, SUM(sal) OVER (ORDER BY empno ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cum_sum
  FROM `bigdata-adhoc.open_mart_ds.emp`
 WHERE job IN ('ANALYST', 'MANAGER');
```

### 51. 데이터 분석 함수로 비율 출력하기 (RATIO_TO_REPORT)

BigQuery 미지원 함수입니다.  교재내의 예시처럼 분석함수를 사용하여 비율을 계산할 수 있습니다.

```sql
SELECT empno, ename, sal, sal / SUM(sal) OVER () AS sal_ration,
  FROM `bigdata-adhoc.open_mart_ds.emp`
 WHERE deptno = 20;
```

### 52. 데이터 분석 함수로 집계 결과 출력하기 ① (ROLLUP)

### 53. 데이터 분석 함수로 집계 결과 출력하기 ② (CUBE)

### 54. 데이터 분석 함수로 집계 결과 출력하기 ② (GROUPING SETS)


### 55. 데이터 분석 함수로 출력 결과 넘버링 하기 (ROW_NUMBER)

다음은 회사내 월급에 대한 순위입니다. 함수에 따라서 순위를 매기는 방식이 조금씩 상이합니다.

```sql
SELECT empno, ename, sal,
       RANK() OVER (ORDER BY sal DESC) AS rank,
       DENSE_RANK() OVER (ORDER BY sal DESC) AS dense_rank,
       ROW_NUMBER() OVER (ORDER BY sal DESC) AS rn
  FROM `bigdata-adhoc.open_mart_ds.emp`;
```

부서별 월급에 대한 순위를 보여줍니다.
```sql
SELECT empno, ename, sal,
       ROW_NUMBER() OVER (PARTITION BY deptno ORDER BY sal DESC) AS rn
  FROM `bigdata-adhoc.open_mart_ds.emp`;
```
