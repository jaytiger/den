---
title: "SQL 200 - Part II-1"
permalink: /docs/study/sql200/part2_2/
last_modified_at: 2022-07-03T10:00:00
layout: single
#classes: wide
toc: true
toc_sticky: true
sidebar:
  nav: "sql200"
---

## Part 2. SQL 기초 다지기

#### 41. 데이터 분석 함수로 순위 출력하기 ① (RANK)

```sql
SELECT ename, job, sal, RANK() OVER (ORDER BY sal DESC) rank
  FROM `bigdata-adhoc.open_mart_ds.emp`
 WHERE job IN ('ANALYST', 'MANAGER')
;
```

집계함수와 분석함수의 가장 큰 차이는 집계 함수는 결과값이 집단(그룹)에 대해서 하나만 생성되는 반면, 분석 함수는 집단 구성원 각각에 대해서 만들어 진다는 점입니다.

따라서, 쿼리 수행으로 만들어지는 결과 테이블의 크기는 집계 함수의 경우 **GROUP BY** 에 나열된 컬럼값들로 만들 수 있는 조합의 갯수와 동일합니다. 집계가 이루어지면 결과 테이블은 원 테이블의 크기(행의 갯수)보다 줄어들게 됩니다.

분석함수는 집단이 아닌 각 구성원(테이블의 행)에 대해서 하나의 결과값이 생성되기 때문에 쿼리 수행 전후의 테이블의 크기가 동일합니다.

```sql
SELECT ename, job, sal, RANK() OVER (PARTITION BY job ORDER BY sal DESC) rank
  FROM `bigdata-adhoc.open_mart_ds.emp`
;
```
#### 42. 데이터 분석 함수로 순위 출력하기 ② (DENSE_RANK)

```sql
SELECT ename, job, sal,
       RANK() OVER (PARTITION BY job ORDER BY sal DESC) rank,
       DENSE_RANK() OVER (PARTITION BY job ORDER BY sal DESC) dense_rank
  FROM `bigdata-adhoc.open_mart_ds.emp`
 WHERE job IN ('ANALYST', 'MANAGER')
;
```

```sql  -- 예제_042-2.txt
SELECT ename, job, sal,
       DENSE_RANK() OVER (PARTITION BY job ORDER BY sal DESC) dense_rank
  FROM `bigdata-adhoc.open_mart_ds.emp`
 WHERE hiredate BETWEEN  '1981-01-01' AND '1981-12-31'
;
```

교재의 아래 쿼리는 BigQuery에서 직접적으로 지원하지 않는 **WITHIN GROUP** 구문을 사용하고 있습니다.
이 구문은 집계 함수에서 **순서(ORDER)** 를 사용할 수 있게 보조하는 문법적인 장치입니다.
\\\
```sql
-- PL/SQL, not BigQuery
SELECT DENSE_RANK(2975) WITHIN GROUP (ORDER BY sal DESC) rank FROM emp;
```

**그룹 내** 에서 **2975** 값의 rank를 구하는 함수입니다.  동일한 결과를 만드는 BigQuery의 코드는 다음과 같습니다.

```sql
SELECT DISTINCT DENSE_RANK() OVER (ORDER BY sal DESC) rank
  FROM `bigdata-adhoc.open_mart_ds.emp`
 WHERE sal = 2975
;
```

동일하게 입사일이 **'1981-11-17'** 인 직원이 몇 번째 입사자인지 구하는 쿼리는 다음과 같습니다.
```sql
-- PL/SQL, not BigQuery
SELECT DENSE_RANK('81/11/17') WITHIN GROUP (ORDER BY hiredate ASC) rank FROM emp;

-- BigQuery
SELECT DISTINCT DENSE_RANK() OVER (ORDER BY hiredate DESC) rank
  FROM `bigdata-adhoc.open_mart_ds.emp`
 WHERE hiredate = '1981-11-17'
;
```

#### 43. 데이터 분석 함수로 순위 출력하기 ② (DENSE_RANK)

```sql
SELECT ename, job, sal,
       NTILE(4) OVER (ORDER BY sal DESC NULLS LAST)) tile,
  FROM `bigdata-adhoc.open_mart_ds.emp`
 WHERE job IN ('ANALYST', 'MANAGER', 'CLERK')
;
```

### 44. 데이터 분석 함수로 순위의 비율 출력하기 (CUME_DIST)

누적분포(Cumulative Distribution) 함수

```sql
SELECT ename, sal,
       RANK() OVER (ORDER BY sal DESC) AS rank,
       DENSE_RANK() OVER (ORDER BY sal DESC) AS dense_rank,
       CUME_DIST() OVER (ORDER BY sal DESC) AS cum_dist,
  FROM `bigdata-adhoc.open_mart_ds.emp`
;
```

```sql
SELECT ename, sal,
       RANK() OVER (PARTITION BY job ORDER BY sal DESC) AS rank,
       CUME_DIST() OVER (PARTITION BY ORDER BY sal DESC) AS cum_dist,
  FROM `bigdata-adhoc.open_mart_ds.emp`
;
```

### 45. 데이터 분석 함수로 데이터를 가로로 출력하기 (LISTAGG)

```sql
-- PL/SQL, BigQuery 미지원
SELECT deptno, LISTAGG(ename, ',') WITHIN GROUP (ORDER BY ename) AS employee
  FROM emp
 GROUP BY deptno;
```
**LISTAGG** 는 BigQuery에서 미지원되는 함수입니다. BigQuery에서는 동일한 기능을 제공하는 **STRING_AGG** 함수를 사용합니다.

```sql
-- BigQuery
SELECT deptno, STRING_AGG(ename,  ',' ORDER BY ename) AS employee
  FROM `bigdata-adhoc.open_mart_ds.emp`
 GROUP BY deptno;
```

```sql
SELECT job, STRING_AGG(ename || '(' || sal || ')',  ',' ORDER BY ename) AS employee
  FROM `bigdata-adhoc.open_mart_ds.emp`
 GROUP BY job;
```

### 46. 데이터 분석 함수로 바로 전 행과 다음 행 출력하기 (LAG, LEAD)

```sql
SELECT empno, ename, sal,
       LAG(sa1, 1) OVER (ORDER BY sal ASC) pre,
       LEAD(sa1, 1) OVER (ORDER BY sal ASC) next,
  FROM `bigdata-adhoc.open_mart_ds.emp`
 WHERE job IN ('ANALYST', 'MANAGER')
```

```sql
SELECT empno, ename, hiredate,
       LAG(hiredate, 1) OVER (ORDER BY hiredate ASC) pre,
       LEAD(hiredate, 1) OVER (ORDER BY hiredate ASC) next,
  FROM `bigdata-adhoc.open_mart_ds.emp`
 WHERE job IN ('ANALYST', 'MANAGER')
```

```sql
SELECT deptno, empno, ename, hiredate,
       LAG(hiredate, 1) OVER (PARTITION BY deptno ORDER BY hiredate ASC) pre,
       LEAD(hiredate, 1) OVER (PARTITION BY deptno ORDER BY hiredate ASC) next,
  FROM `bigdata-adhoc.open_mart_ds.emp`
;
```

### 47. COLUMN을 ROW로 출력하기 ① (SUM + DECODE)

**DECODE** 함수는 BigQuery에서 제공되지 않습니다. 비교적 단순한 형태라서 BigQuery **IF** 함수를 사용하여 동일한 결과가 나오도록 해보겠습니다.

```sql
-- PL/SQL, not BigQuery
SELECT SUM(DECODE(deptno, 10, sal)) AS '_10',
       SUM(DECODE(deptno, 20, sal)) AS '_20',
       SUM(DECODE(deptno, 30, sal)) AS '_30'
  FROM emp
```

-- PL/SQL, not BigQuery
SELECT SUM(IF(deptno = 10,sal, NULL)) AS '_10',
       SUM(IF(deptno = 20,sal, NULL)) AS '_20',
       SUM(IF(deptno = 30,sal, NULL)) AS '_30',
  FROM `bigdata-adhoc.open_mart_ds.emp`

